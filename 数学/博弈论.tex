策梅洛定理（Zermelo's theorem）指出，若一个游戏满足如下条件：

1.双人、回合制；

2.信息完全公开（perfect information）；

3.无随机因素（deterministic）；

4.必然在有限步内结束；

5.没有平局；

则游戏中的任何一个状态，要么先手有必胜策略，要么后手有必胜策略（下文把这两种状态分别称为“胜态”、“败态”）。

　　常见的牌类游戏大多不满足条件2、3；常见的棋类游戏（如井字棋、五子棋、围棋、象棋、跳棋）大多满足条件2、3，在正式竞技中也会通过禁止循环的方式保证条件4，但不一定满足条件5。而第一节中提出的三种游戏，满足全部5个条件。

　　策梅洛定理的结论其实颇为显然。它的证明过程也就是必胜策略的构造过程：

对于终局状态，根据游戏规则可以判定“先手者”（即面对此状态的玩家）的胜负；
对于非终局状态A，可以考虑先手玩家走一步之后的所有可能状态（称为A的“次态”）：若A的次态全都是胜态，则A本身就是败态；否则，A为胜态，且必胜策略就是在次态中选择一个败态留给对方。由于游戏会在有限步内结束，这个递归过程必然能够终止。
　　根据策梅洛定理，可以很容易地使用记忆化搜索算法判断一个状态是胜态还是败态：

\begin{lstlisting}
mem = {}
def win(A):                     # 判断状态A是否为胜态
    if A not in mem:
        if is_final(A):         # 若A为终局态
            mem[A] = rule(A)    # 根据游戏规则判断A的胜负
        else:                   # 若A为非终局态，则根据策梅洛定理判断其胜负
            mem[A] = not all(win(B) for B in next_states(A))
                                # next_states(A)返回A的所有次态
    return mem[A]

\end{lstlisting}

　　需要注意，这里的“状态”是需要包含“下一步轮到谁”这一信息的。另外需要讨论一下游戏满足的第4个条件——策梅洛定理本身只要求游戏在有限步内结束，但如果要使用上面的记忆化搜索算法，则需要枚举一个状态的所有次态，这要求在游戏中每一步的可能走法数也是有限的。下文也只讨论游戏的总步数和每步的走法数都有限的情况，这种游戏称为“有限游戏”（finite game）。

游戏状态的组合

　　有些读者可能已经发现了，在第一节提出的三种游戏中，有许多状态是等价的。例如在Flip Game中，两个加号（“++”）和三个加号（“+++”）就是等价的状态，因为它们都是走一步之后就无路可走；在抢票游戏中，一个2x3的矩形和一个3x2的矩形也是等价的状态。状态的等价有许多种原因，其中一种是因为两个状态都是同样一些相互独立的子状态的组合。这里，“相互独立”的意思是指玩家的任意一步行动都只能影响一个子状态。例如，在Flip Game中，“++++-++--”和“-++--++++”就是等价的状态，因为它们都是“2个加号”和“4个加号”这两个子状态的组合。而Nim游戏的状态天然就是一些子状态的组合，其中每堆石子是一个子状态。如果能够通过子状态的胜负推断出它们的组合（下文称为“母状态”）的胜负，那么就可以大幅减少记忆化搜索过程中需要考虑的状态数，提高搜索效率。

　　在讨论由子状态胜负推断母状态胜负的方法之前，我想先指出第一节中三个游戏的另外三个共同特征。它们正是Sprague-Grundy定理成立的条件，也是下文所有讨论的前提。

游戏双方可以采取的行动是相同的。井字棋、五子棋、围棋、象棋、跳棋这些棋类游戏均不满足这个条件，因为游戏的双方只能下（或移动）己方的棋子。
游戏双方的胜利目标是相同的。常见的胜利目标包括把棋盘清空或填满，或者把棋子排成特定的形状。注意，如果双方的目标是把棋子排成不同的形状，则游戏不满足这个条件。

满足上面两个条件的游戏称为impartial game，反之则称为partisan game。impartial game的状态中只需包含棋盘信息，partisan game的状态则还需包括“下面轮到谁”。正因为如此，partisan game的状态无法拆分成“相互独立”的子状态，因为玩家的每一步行动会影响到所有子状态中“下面轮到谁”的信息。
双方的胜利目标具体来说，是自己亲手达成终局状态，或者说走最后一步者为胜（术语称为normal play）。第一节中的三个游戏也都可以稍微修改规则，改成走最后一步者为负（术语称为misère play），但下文的讨论仅适用于normal play的情况。
　　下面讨论状态的组合对胜负的影响。请温习一下胜态和败态的关键性质：经过一步行动，败态只能变成胜态，胜态可以（但不一定）变成败态。

　　先看两个败态的组合。两个败态的组合还是败态。从后手玩家的角度来看，先手玩家的行动只能将两个败态中的一个改变为胜态，于是后手玩家可以再将这个胜态变成败态，从而将两个败态的组合抛回给先手玩家。由于终局状态为败态，最终先手玩家必将面对两个终局状态组成的败态，故后手必胜。

　　再看一胜一败两个状态的组合。胜态与败态的组合还是胜态——先手玩家只要把胜态变成败态，就可以把两个败态组合成的败态抛给后手玩家了。

　　最后看两个胜态的组合。这种组合就比较复杂了：先手玩家不应把其中一个胜态变成败态，因为这样会把一胜一败两个状态组合成的胜态留给对方。因此，先手玩家应当把其中一个胜态变成一个新的胜态。后手玩家面对新的胜态+胜态的组合，应当采取相同的策略。然而，由于游戏是有限的，早晚会有一个玩家只能把一个胜态变成败态，从而输掉游戏，但我们并不知道这会在哪一步发生。也就是说，仅仅知道两个子状态都是胜态，不足以推出母状态的胜负；我们需要挖掘胜态的更多性质。

Sprague-Grundy数的提出

　　我们以Flip Game为例，研究一下胜态还有什么更深入的性质。

　　状态“++”是最简单的胜态，它只有一种走法，结果是败态。状态“+++”跟“++”在这一点上是一样的，因此它们其实是等价状态。状态“++++”就有两种不同的走法（对称的走法算同一种）：一是把中间两个加号变成减号，这样得到的次态“+--+”是个败态；二是把某一端的两个加号变成减号，这样得到的次态“--++”或“++--”（等价于“++”）是个胜态。

　　于是我们发现了两种不同的胜态。像“++”、“+++”这样，只能变成败态的胜态，我们称之为“一级胜态”。像“++++”这样，可以变成败态，也可以变成一级胜态的胜态，我们称之为“二级胜态”。类似地，如果一个胜态可以变成败态，也可以变成1至n-1级的所有胜态，则我们称之为“n级胜态”。而败态可以称为“零级”。

　　我们看一下胜态的组合是否与级数有关。两个一级胜态的组合是败态，因为先手玩家的任意一步行动都会将其中一个胜态变为败态，留给后手玩家的就是胜态与败态组合成的胜态。一个一级胜态与一个二级胜态的组合是胜态，因为先手玩家可以将二级胜态变为一级胜态，留给后手玩家的就是两个一级胜态组合成的败态。两个二级胜态组合成的胜态也是败态，因为先手玩家无论将其中一个二级胜态变成败态还是一级胜态，留给对方的组合都是胜态。

　　我们似乎发现了一个规律：两个同级胜态的组合是败态，两个不同级胜态的组合是胜态。没错！考察两个同级胜态的组合，无论先手玩家如何降低其中一个胜态的级数（甚至将其变成零级的败态），后手玩家总可以将另一个胜态降到同一级，最终先手玩家将面对两个败态组合成的败态。而若先手玩家面对的是两个不同级的胜态，他就总可以将其中较高级的胜态降至与较低级的胜态同级，这样留给后手玩家的就是败态。

　　上面对于胜态等级的定义有一个漏洞：如果一个胜态A可以变成败态或二级胜态，但不能变成一级胜态，那么它应该算一级还是三级呢？规律的证明过程同样也有一个漏洞：我们默认了一步行动只能让胜态的级数降低，那么能不能让胜态的级数升高呢？注意到规律证明过程的关键，在于如果要降低一个胜态的级数，则可以降低到任一级。于是我们就知道，上面的状态A应当定义为一级胜态。这导致胜态的级数可以升高，不过没关系，可以这样弥补规律证明的漏洞：在两个同级胜态的组合下，若先手玩家升高了其中一个胜态的级数，则后手玩家可以将它降回原级，这样两个同级胜态的组合仍是败态。

　　通过定义胜态的级数，我们解决了两个胜态组合而成的母状态的胜负判定问题。事实上，我们定义的“级数”，就是传说中的Sprague-Grundy数（简称SG数）。SG数是一个从状态映射到非负整数的函数，它的形式化定义如下：

$$
SG(A) = mex\{ SG(B)| A \to B\}
$$

式中A、B代表状态，$A \to B$代表B是A的一个次态。mex是一个定义在集合上的函数，表示不属于集合的最小非负整数，它是minimum excludant的缩写。这个定义用通俗的语言表达，就是说一个状态的SG数，等于它的次态取不到的最小SG数。

状态组合时Sprague-Grundy数的运算规则

有了SG数，我们就可以判断任意两个子状态组合成的母状态的胜负了。但是，如果一个母状态是由三个子状态组成的，怎么办？我们发现，仅仅判断两个子状态组合成的母状态的胜负是不够的，我们还需要求出母状态的SG数。在下文中，我们用$a \oplus b = c$表示SG数分别为a、b的两个子状态组合成的母状态的SG数为c，我们的目标，就是弄清$\oplus$运算的法则。当然，我们这么写默认了由子状态的SG数可以唯一确定母状态的SG数，这一点其实未经证明。

　　依然从最简单的情况开始。两个败态的组合还是败态，也就是说$0 \oplus 0 = 0$。两个一级胜态的组合也是败态，即$1 \oplus 1 = 0$。一个败态和一个一级胜态的组合，我们可以考虑最简单的情况：败态是终局态，不能再改变；而一级胜态只能变成败态。显然，这个组合的次态只能是两个败态组成的败态，故它本身是一级胜态，即$0 \oplus 1 = 1$。

　　——$0 \oplus 0 = 0$，$1 \oplus 1 = 0$，$0 \oplus 1 = 1$，聪明的读者，你看出规律了吗？

　　如果你没看出规律，或者不相信你看出的规律，我们可以再算几个SG数稍微大一点儿的情况。考虑最简单的败态和二级胜态的组合：败态不能变化，二级胜态只能变成一级胜态或败态，于是组合的次态的SG数只能是$0 \oplus 1 = 1$或$0 \oplus 0 = 0$。这说明败态和二级胜态的组合是二级胜态，即$0 \oplus 2 = 2$。同理可得$0 \oplus 3 = 3$。再看胜态和胜态的组合。前面已经得到，两个同级胜态的组合为败态，故$2 \oplus 2 = 3 \oplus 3 = 0$。那么两个不同级胜态的组合呢？

$1 \oplus 2$的次态可能是$0 \oplus 2 = 2$、$1 \oplus 0 = 1$、$1 \oplus 1 = 0$，次态的SG数中0、1、2俱全，故$1 \oplus 2 = 3$。

$1 \oplus 3$的次态可能是$0 \oplus 3 = 3$、$1 \oplus 0 = 1$、$1 \oplus 1 = 0$、$1 \oplus 2 = 3$，次态的SG数缺少2，故$1 \oplus 3 = 2$。

$2 \oplus 3$的次态可能是$0 \oplus 3 = 3$、$1 \oplus 3 = 2$、$2 \oplus 0 = 2$、$2 \oplus 1 = 3$、$2 \oplus 2 = 0$，次态的SG数缺少1，故$2 \oplus 3 = 1$。

　　现在看出规律了吗？相信了吗？

　　我们再换个角度，看看我们已经得到了$\oplus$运算的哪些性质：

交换律$a \oplus b = b \oplus a$：显然；

结合律$(a \oplus b) \oplus c = a \oplus (b \oplus c)$：显然；

归零律$a \oplus a = 0$：因为两个同级胜态的组合为败态；

恒等律$0 \oplus a = 0$：本节已用最简单的情况说明。

具有这四个性质的二元运算是什么呢？是异或！

　　到此为止，我们通过举例的方法，发现了状态的组合对应着SG数的异或。不过，我们并没有证明通过子状态的SG数能够唯一确定母状态的SG数（即$\oplus$运算结果的唯一性），也没有证明异或是能够达到这个目的的唯一一种运算。下面，我们就通过SG数和状态组合的定义，证明状态的组合对应着SG数的异或，即$SG(A+B)=SG(A) \oplus SG(B)$，其中加号表示状态的组合，$\oplus$号表示异或。


下面给出Sprague-Grundy定理的完整表述：

　　若一个游戏满足以下条件：

　　1. 双人、回合制；

　　2. 信息完全公开（perfect information）；

　　3. 无随机因素（deterministic）；

　　4. 必然在有限步内结束，且每步的走法数有限（finite）；

　　5. 没有平局；

　　6. 双方可采取的行动及胜利目标都相同（impartial）；

　　7. 这个胜利目标是自己亲手达成终局状态，或者说走最后一步者为胜（normal play）；

则游戏中的每个状态可以按如下规则赋予一个非负整数，称为Sprague-Grundy数：
　　
	$$
	SG(A) = mex\{ SG(B)| A \to B\}
	$$

（式中A、B代表状态，$A \to B$代表A状态经一步行动可以到达B状态，mex表示一个集合所不包含的最小非负整数）。SG数有如下性质：

　　1. SG数为0的状态，后手必胜；SG数为正的状态，先手必胜；

　　2. 若一个母状态可以拆分成多个相互独立的子状态，则母状态的SG数等于各个子状态的SG数的异或。

　　利用Sprague-Grundy定理，可以将记忆化搜索的程序优化成如下形式：

\begin{lstlisting}
mem = {}
def SG(A):                      # 求状态A的SG数
    if A not in mem:
        S = sub_states(A)       # sub_states(A)将A尽可能细致地拆分成子状态
        if len(S) > 1:          # A可以拆分，用子状态的异或求其SG数
            mem[A] = reduce(operator.xor, [SG(B) for B in S])
        else:                   # A不可拆分，根据定义求其SG数
            mem[A] = mex(set(SG(B) for B in next_states(A)))
                                # next_states(A)返回A的所有次态
                                # 注意这条语句蕴含了“终局态的SG数为0”
    return mem[A]
\end{lstlisting}